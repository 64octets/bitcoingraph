#!/usr/bin/env python

import argparse
import sys
import logging

import bitcoingraph as bcgraph
from bitcoingraph.blockchain import BlockChain, BlockchainException
from bitcoingraph.rpc import (BitcoinProxy,
                              JSONRPCException, DEFAULT_SERVICE)

import bitcoingraph.graphgen as etg

def progress(progress=0):
    progress = int(progress * 100)
    sys.stdout.write("\rProgress: {0}%".format(progress))
    sys.stdout.flush()

def setup_logger(args):
    args = args
    logger = None

    if args.logging:
        # Set log message format
        #formatter = logging.Formatter( '%(asctime)s - %(name)s - %(levelname)s - %(message)s' )
        #formatter = logging.Formatter( '%(asctime)s - %(levelname)s - %(message)s' )
        formatter = logging.Formatter( '%(levelname)s - %(message)s' )

        # Set loglevel
        numeric_level = getattr(logging, args.loglevel.upper(), None)
        if not isinstance(numeric_level, int):
            print("Invalid log level: {}, defaulting to 'DEBUG'".format(args.loglevel,))
            numeric_level = getattr(logging, "DEBUG", None)
        logger = logging.getLogger( "l" ) # some name for logger
        logger.setLevel(level=numeric_level)

        if args.logfile:
            # create RotatingFile handler with max 10 logFiles with max 100MB each
            rf = logging.handlers.RotatingFileHandler( args.logfile, maxBytes=104857600, backupCount=10 )
            rf.setLevel( numeric_level )
            rf.setFormatter( formatter )
            logger.addHandler( rf )
        else:
            # create stdout stream handler
            ch = logging.StreamHandler()
            ch.setLevel( numeric_level )
            ch.setFormatter( formatter )
            logger.addHandler( ch )
        logger.debug('Configured logger for loglevel: {}'.format(numeric_level))
    return logger

def generate_txin_graph(args):
    print("Starting transaction graph generation.")
    service_cred = args.user + ':' + args.password
    service_uri = 'http://' + service_cred + '@' + args.service + '/'
    print("Attempting to connect to %s ..." % service_uri)
    try:
        bc_proxy = BitcoinProxy(service_uri)
        bc_proxy.getinfo()
        print("Connection successful.")
    except JSONRPCException:
        print("Couldn't connect to %s. Aborting." % args.bitcoin_rpc_uri)
        sys.exit(1)

    try:
        blockchain = BlockChain(bc_proxy)
        with open(args.output_file, 'w') as csv_file:
            bcgraph.generate_txin_graph(blockchain, args.startheight,
                                      args.endheight, csv_file, progress)
    except JSONRPCException as exc:
        print("\nConnection error %s" % exc)
    except BlockchainException as exc:
        print("\nBlockchain error %s" % exc)
    print("\nFinished transaction graph generation.")


def generate_tx_graph(args):
    print("Starting transaction graph generation.")
    service_cred = args.user + ':' + args.password
    service_uri = 'http://' + service_cred + '@' + args.service + '/'
    print("Attempting to connect to %s ..." % service_uri)
    try:
        bc_proxy = BitcoinProxy(service_uri)
        bc_proxy.getinfo()
        print("Connection successful.")
    except JSONRPCException:
        print("Couldn't connect to %s. Aborting." % args.bitcoin_rpc_uri)
        sys.exit(1)

    try:
        blockchain = BlockChain(bc_proxy)
        bcgraph.export_tx_graph(blockchain, args.startheight,
                                args.endheight, args.output_file, progress)
    except JSONRPCException as exc:
        print("\nConnection error %s" % exc)
    except BlockchainException as exc:
        print("\nBlockchain error %s" % exc)
    print("\nFinished transaction graph generation.")

def generate_et_graph(args):
    logger = setup_logger(args)

    if (args.txgcsv):
        txgcsv = str(args.txgcsv)
        if logger: logger.info("Tx graph file {}\nStarting ...".format(txgcsv))
        else:   print("Tx graph file {}\nStarting ...".format(txgcsv))
        
        etgenerator = etg.EtGraphGen(logger=logger)
        etgenerator.gen_entity_mapping(txgcsv)

        if (args.btcmapcsv):
            btcmapcsv = str(args.btcmapcsv)
            etgenerator.print_btcaddr_mapping(btcmapcsv)
            if logger: logger.info("Bitcoin address mapping output file: {}".format(btcmapcsv))
            else: print("Bitcoin address mapping output file: {}".format(btcmapcsv))

        if (args.etmapcsv):
            etmapcsv = str(args.etmapcsv)
            etgenerator.print_entity_mapping(etmapcsv)
            if logger: logger.info("Entity mapping output file: {}".format(etmapcsv))
            else: print("Entity mapping output file: {}".format(etmapcsv))

        if (args.etgcsv):
            etgcsv = str(args.etgcsv)
            etgenerator.print_entity_graph(etgcsv, txgcsv)
            if logger: logger.info("Entity graph output file: {}".format(etgcsv))
            else: print("Entity graph output file: {}".format(etgcsv))

    else:
        if logger: logger.error("No input transaction graph csv given. Aporting")
        else:   print("No input transaction graph csv given. Aporting")

    return 0


parser = argparse.ArgumentParser(
    description="Generates graph data sets from the Bitcoin Blockchain")

# Define subparsers for each command
subparsers = parser.add_subparsers(
    help="Bitcoin graph generation sub-command help")

# Parser for transaction graph generation
tx_graph_parser = subparsers.add_parser(
    "tx_graph",
    help="Transaction graph generation help")
tx_graph_parser.add_argument("startheight", type=int,
                             help="Start block height")
tx_graph_parser.add_argument("endheight", type=int,
                             help="End block height")
tx_graph_parser.add_argument("-s", "--service",
                             default=DEFAULT_SERVICE,
                             help="Address of Bitcoin JSON RPC Service")
tx_graph_parser.add_argument("-u", "--user", required=True,
                             help="Bitcoin Core RPC username")
tx_graph_parser.add_argument("-p", "--password", required=True,
                             help="Bitcoin Core RPC password")
tx_graph_parser.add_argument("-o", "--output_file", type=str,
                             default="tx_graph.csv",
                             help="Output file name")
tx_graph_parser.set_defaults(func=generate_tx_graph)


tx_graph_parser = subparsers.add_parser(
    "txin_graph",
    help="Transaction input graph generation help")
tx_graph_parser.add_argument("startheight", type=int,
                             help="Start block height")
tx_graph_parser.add_argument("endheight", type=int,
                             help="End block height")
tx_graph_parser.add_argument("-s", "--service",
                             default=DEFAULT_SERVICE,
                             help="Address of Bitcoin JSON RPC Service")
tx_graph_parser.add_argument("-u", "--user", required=True,
                             help="Bitcoin Core RPC username")
tx_graph_parser.add_argument("-p", "--password", required=True,
                             help="Bitcoin Core RPC password")
tx_graph_parser.add_argument("-o", "--output_file", type=str,
                             default="tx_graph.csv",
                             help="Output file name")
tx_graph_parser.set_defaults(func=generate_txin_graph)



et_graph_parser = subparsers.add_parser(
    "et_graph",
    help="Entity graph generation help")
et_graph_parser.add_argument('-l',
                action='store_true',
                default = False,
                dest='logging',
                help='Enable Logging')
et_graph_parser.add_argument('-lf',
                action='store_true',
                default = False,
                dest='logfile',
                help='Enable Logging to file, default is stdout when -l flag is given')
et_graph_parser.add_argument('-lv',
                action='store',
                default='DEBUG',
                dest='loglevel',
                type=str,
                help='Set the loglevel, default is DEBUG when -l flag is given')
et_graph_parser.add_argument('-t','--txgcsv',
                action='store',
                default=None,
                dest='txgcsv',
                type=str,
                help='The path and name to the transaction graph csv file')
et_graph_parser.add_argument('-o','--output',
                action='store',
                default=None,
                dest='etgcsv',
                type=str,
                help='The path and name to the entity graph csv file')
et_graph_parser.add_argument('-e','--etmapout',
                action='store',
                default=None,
                dest='etmapcsv',
                type=str,
                help='The path and name to the entity mapping csv file.')
et_graph_parser.add_argument('-b','--btcmapout',
                action='store',
                default=None,
                dest='btcmapcsv',
                type=str,
                help='The path and name to the btcaddr mapping csv file.')
et_graph_parser.set_defaults(func=generate_et_graph)


if len(sys.argv) <= 2:
    parser.print_help()
    sys.exit(1)

args = parser.parse_args()
args.func(args)
